/*
 * Copyright (c) 2019 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <inttypes.h>
#include <stddef.h>
#include <stdint.h>
#include <errno.h>
#include <stdio.h>
#include <math.h>

#include <zephyr/kernel.h>
#include <zephyr/device.h>
// #include <zephyr/drivers/pwm.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/adc.h>
#include <zephyr/sys/util.h>
#include <zephyr/types.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/hci.h>
#include <zephyr/drivers/spi.h>


#if !DT_NODE_EXISTS(DT_PATH(zephyr_user)) || \
	!DT_NODE_HAS_PROP(DT_PATH(zephyr_user), io_channels)
#error "No suitable devicetree overlay specified"
#endif

// General note: DT == DeviceTree (.dts is device tree settings)

#define DT_SPEC_AND_COMMA(node_id, prop, idx) \
	ADC_DT_SPEC_GET_BY_IDX(node_id, idx),

/* Data of ADC io-channels specified in devicetree. */
// For each element in io_channels (an autogenerated node from the .dts file), get a handle to it's adc_dt_spec
static const struct adc_dt_spec adc_channels[] = {
	DT_FOREACH_PROP_ELEM(DT_PATH(zephyr_user), io_channels,
			     DT_SPEC_AND_COMMA)
};

#define LED_ON          0
#define LED_OFF         1

// Get the device tree handles by their friendly name from the macro-snap.dts file
// static const struct pwm_dt_spec cyber_led = PWM_DT_SPEC_GET(DT_ALIAS(pwm0));
static const struct gpio_dt_spec blue_led = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);
// static const struct gpio_dt_spec red_led = GPIO_DT_SPEC_GET(DT_ALIAS(led2), gpios);
// static const struct gpio_dt_spec cs_hapt = GPIO_DT_SPEC_GET(DT_ALIAS(spi0), gpios);
static const struct gpio_dt_spec ui_btn = GPIO_DT_SPEC_GET_OR(DT_ALIAS(uibtn), gpios,{0});
static const struct gpio_dt_spec fsr_det = GPIO_DT_SPEC_GET_OR(DT_ALIAS(fsrdet), gpios,{0});

/* SPI defines for the BOS1901 haptic driver*/
#define BOS1901_MANUFACTURER_ID_ADDR 0x02
#define BOS1901_REG_REF_ADDR 0x0
#define BOS1901_REG_REF_AMP_DATA 0b111110010010 //110 (calculated from formula for 12V output) in two's complement
#define BOS1901_REG_KP_ADDR 0x03
#define BOS1901_REG_KP_SQ_MASK 0b111111111111 //masks are setup to && with whatever is already in there
#define BOS1901_REG_KP_NO_SQ_MASK 0b011111111111
#define BOS1901_REG_KP_DATA 0x080
#define BOS1901_REG_KPA_KI_ADDR 0x04
#define BOS1901_REG_CONFIG_ADDR 0x05
#define BOS1901_REG_CONFIG_OE_MASK 0b111110010000 //masks are setup to && with whatever is already in there
#define BOS1901_REG_CONFIG_NO_OE_MASK 0b111110000000 //masks are setup to && with whatever is already in there

//////////////////////SPIIIIIII FUNCTIONS BEGIN /////////////////////////////////////////////////////////////////////////////////////////
///ALL the spi read_write shit ////////////////////////////////////////////
const struct device * spi_dev = DEVICE_DT_GET(DT_ALIAS(spizero)); 

//note that cs is being set by the blue LED gpio currently
static const struct spi_config spi_cfg = {
	.operation = SPI_WORD_SET(8) | SPI_TRANSFER_MSB |
		     SPI_MODE_CPOL | SPI_MODE_CPHA | SPI_OP_MODE_MASTER,
	.frequency = 8000000,
	.slave = 0, //0
	// .cs = 1,
};

uint16_t spi_read_write(uint8_t combo_word_1, uint8_t combo_word_2)
{
	int err;
	// static uint8_t tx_buffer[2]; //this should return the manufacturer id in rx buffer (hopefully)
	// static uint8_t rx_buffer[2];

	uint8_t rx_dummy= 0x00;
	uint8_t rx_dummy2= 0x00;

	struct spi_buf tx_buffer[] = 
	{
	{
		.buf = &combo_word_1,
		.len = (size_t) sizeof(combo_word_1)
	},
	{
		.buf = &combo_word_2,
		.len = (size_t) sizeof(combo_word_2)
	}
	};
	struct spi_buf rx_buffer[] = {
		{
		.buf = &rx_dummy,
		.len = (size_t) sizeof(rx_dummy)
		},
		{
		.buf = &rx_dummy2,
		.len = (size_t) sizeof(rx_dummy2)			
		}
	};

	struct spi_buf_set tx = {
		.buffers = tx_buffer,
		.count = 2
	};

	struct spi_buf_set rx = {
		.buffers = rx_buffer,
		.count = 2
	};
    gpio_pin_toggle_dt(&blue_led);
	err = spi_transceive(spi_dev, &spi_cfg, &tx, &rx);
    gpio_pin_toggle_dt(&blue_led);

	
	uint16_t rx_receive = ((uint16_t)rx_dummy << 8) | rx_dummy2;
	return rx_receive;
}
/////////////////////////////////////////////////////////////////////////////////////////

//Reference Values
#define REFERENCE_ZERO       0x0000
#define REFERENCE_PLUS_1LSB  0x0001
#define REFERENCE_MINUS_1LSB 0x0FFF

//Feedback
#define SIGNAL_SIZE_MAX             256 // Maximum table size
#define PRESS_SIGNAL_VOLTAGE        12  // Volts -> try making this larger
#define PRESS_SIGNAL_FREQ           60 // Hertz
#define REG_READ_VFEEDBACK_MASK     0x03FF

// Piezo Creep
#define CREEP_HOLD_TIME     40 // Cycles of 125us (8kHz)

// Timer
#define TIMER_PERIOD_ACCEL  3 // 3 ticks faster than 125-1

// Trimming
#define FIFO_SPACE_MASK (0x7F)
#define MAX_TRY         10800
#define TRIM_OSC_MAX_POS 0x1F
#define TRIM_OSC_MASK    0x3F

//playback defines
#define SAMPLING_RATE	(8000)
#define PLAY_SAMPLING_RATE (8000)


// variables for haptic algo
static uint16_t press_waveform[SIGNAL_SIZE_MAX];   // Press feedback waveform data points
static uint16_t press_waveform_size = 0;           // Press feedback waveform number of data points

// Period variables associated with interrupt timer2
static volatile uint32_t timer2DefaultPeriod;
static volatile uint32_t timer2NewPeriod;

// Convert value in volts to Amplitude FIFO code
int16_t utilsVolt2Amplitude(float volt)
{
    int16_t amplitude = volt*2047/3.6/31;

    return amplitude;
}

// Calculate Press and Release Feedback Waveforms
static void drivingCalculateWaveforms(void)
{
    // Press Feedback Waveform : single sine pulse
	int boolean_switch_sign = 0;
	int counter = 0;
    press_waveform_size = PLAY_SAMPLING_RATE / PRESS_SIGNAL_FREQ; //about 44
    for(volatile uint8_t i = 0; i < press_waveform_size; i++)
    {
        //press_waveform[i] = utilsVolt2Amplitude(PRESS_SIGNAL_VOLTAGE / 2 * (sin(2*3*i/(press_waveform_size) - 3/2)+1));
		if (boolean_switch_sign == 1)
		{
			press_waveform[i] = utilsVolt2Amplitude(PRESS_SIGNAL_VOLTAGE);
		}
		else
		{
			press_waveform[i] = utilsVolt2Amplitude(0);
		}

		if (counter >= 2 && boolean_switch_sign == 0)
		{
			boolean_switch_sign = 1;
			counter = 0;
		}
		else if (counter >= 2 && boolean_switch_sign == 0)
		{
			boolean_switch_sign = 0;
			counter = 0;
		}
		else
		{
			counter++;
		}
	}
}



// Wait until BOS1901 internal FIFO is empty
static void drivingWaitFifoEmpty()
{
    bool fifoempty = 0;

    //Set up broadcast to read IC_STATUS
    spi_read_write(0x56, 0x17);  // Set BC = IC_STATUS

     // loop until FIFO is empty
    while(!fifoempty)
    {
        uint16_t ic_status_reg = spi_read_write(0xC0, 0x00); // dummy write, get IC_STATUS value
        fifoempty = (ic_status_reg >> 6) & 0x1; // extract EMPTY value.
    }
}

// Software trimming element function
bool drivingSoftwareTrim()
{
	uint16_t reg = 0;
    bool succeed = 0;
	
	//Need to disable the channel to do software trim
    spi_read_write(0x56, 0x07);

    //Set the mode to read trim values from register. Value will be available in TRIM_REGISTER and can be read from CONFIG BC
    spi_read_write(0xE8, 0x00); // TRIMRW = 2, SDOBP = 0, TRIM_OSC = 0, TRIM_REG = 0
	
    //Sets the CONFIG BC to read TRIM register
    spi_read_write(0x57, 0x07);

    //Read TRIM register and add 1 to TRIM_OSC
    reg = spi_read_write(0x57, 0x07);
    uint16_t regMask = 0x3 << 10 | 0x3F << 3;  // mask to manipulate register paramters TRIMRW and TRIM_OSC
    uint16_t TRIM_OSC = ((reg >> 3)  + 0x1) & TRIM_OSC_MASK; // gets TRIM_OSC value and increments 1
    succeed = (((reg >> 3) & TRIM_OSC_MASK) & TRIM_OSC_MAX_POS) != TRIM_OSC_MAX_POS; // check if reached maximum TRIM_OSC value
    reg &= ~regMask; // set TRIM_OSC bits to 0
    reg |= 0x3 << 10; // set TRIMRW to write mode
    reg |= TRIM_OSC << 3; // set new TRIM_OSC value
	uint8_t reg1 = (uint8_t)((reg & 0xFF00) >> 8);
	uint8_t reg2 = (uint8_t)(reg & 0x00FF);

	//Write the register with new TRIM_OSC parameter
    if(succeed)
    {
        spi_read_write(reg1, reg2);
    }
    
	// Reenable output and set BC back to IC_STATUS
    spi_read_write(0x56, 0x17);
    // Clear fifo before exiting
    drivingWaitFifoEmpty();
    
	k_msleep(1); // temp
    
    return succeed;
}

// Trim internal oscillator to fit MCU sampling rate
static void drivingTrimming(void) {


    // Initialization

	// Reset IC
	spi_read_write(0x56, 0xA7);  // Reset IC, set SDO broadcast to SENSE register to read VFEEDBACK, set PLAY sampling rate to 8kSPS.
	k_msleep(1);

	//Set the mode to latch hardware fuses to trim block. Data are available in TRIM register. Trimming will start at factory-trimmed value.
	spi_read_write(0xE4, 0x00); // TRIMRW = 1, SDOBP = 0, TRIM_OSC = 0, TRIM_REG = 0

	//sets BC to IC_STATUS & enables output, PLAY = 8kSPS
	spi_read_write(0x56, 0x17);

  	//set the timer at 8.2kHz to have BOS1901 FIFO clear faster than 8kHz
	 timer2NewPeriod = timer2DefaultPeriod - TIMER_PERIOD_ACCEL;

	uint16_t nbTry = 0;
	uint16_t FifoSpacePrev = 0;
	uint16_t FifoSpace = 0;
	bool FifoFull = 0;
	bool FifoEmpty = 0;
	for(;;) 
	{
			//Send 0 V and try to fill the fifo
			uint16_t reg = spi_read_write(0x00, 0x00);
			FifoSpace = reg & FIFO_SPACE_MASK;
			FifoFull = (reg >> 7) & 1;
			FifoEmpty = (reg >> 6) & 1;
			
			//First time the fifo will be the initial value (should be 0)
			if(nbTry == 0) 
			{
				FifoSpacePrev = FifoSpace;
			}
			nbTry++;
						
			//If FIFO has less space than before, data is accumulating in the FIFO
			if ((FifoSpace < FifoSpacePrev && !FifoEmpty) || FifoFull)
			{	
				if(drivingSoftwareTrim()) // increase oscillator speed
				{
					nbTry = 0;	// redo the loop until the trimming is OK																							
				}
			}
			
			//If you tried for a long time and did not succeed accumulating points in the fifo
			if(nbTry > MAX_TRY) 
			{
				break; // exit trimming loop
			}
		
	}								
	 spi_read_write(0x56, 0x07); // disable output once trimming is done.		

	//set the timer back to 8kHz
	 timer2NewPeriod = timer2DefaultPeriod - TIMER_PERIOD_ACCEL;
}
int counter = 0;
int last_sample = PLAY_SAMPLING_RATE / PRESS_SIGNAL_FREQ; 
// Phase C - Press Feedback Waveform
// Multiple entry function - entered every time the timer expires
static void drivingPressFeedback() 
{
	drivingWaitFifoEmpty(); // wait until BOS1901 internal FIFO is empty before sending the waveform points.
	spi_read_write(0x77, 0xE7);  // set SENSE = 0 to drive the output

    if(counter<last_sample) // playing the waveform
    {
		uint8_t reg1 = (uint8_t)((press_waveform[counter] & 0xFF00) >> 8);
		uint8_t reg2 = (uint8_t)(press_waveform[counter] & 0x00FF);
        spi_read_write(reg1, reg2);// Timer expired: send a new point
		counter++;
    } 
    else // waveform reached its last point
    {
        counter = 0;// cleanup
		uint8_t reg1 = (uint8_t)((press_waveform[counter] & 0xFF00) >> 8);
		uint8_t reg2 = (uint8_t)(press_waveform[counter] & 0x00FF);
        spi_read_write(reg1, reg2); // completing the waveform by playing the initial point again.
    }
}

// Phases D - Press Creep Stabilization
// Single entry function - executed once when called
static void drivingPressCreepStabilization()
{
	volatile uint16_t ignore = spi_read_write(0x56, 0x07); // disable output once trimming is done.
	// uint8_t reg1 = (uint8_t)((REFERENCE_MINUS_1LSB & 0xFF00) >> 8);
	// uint8_t reg2 = (uint8_t)(REFERENCE_MINUS_1LSB & 0x00FF);	
    // spi_read_write(reg1, reg2);   // set FIFO to 0x0FFF
    // k_msleep(1000*CREEP_HOLD_TIME/SAMPLING_RATE); // wait defined time
}

void play_haptic_buzz_normal ()
{
	for (int a = 0; a < 80; a++)
	{
		drivingPressFeedback();
		k_msleep(5);
		drivingPressCreepStabilization(); //this causes output to be disabled
		k_msleep(5);
	}
}

//////////////////////SPIIIIIII FUNCTIONS END /////////////////////////////////////////////////////////////////////////////////////////
//for bluetooth test
#define DEVICE_NAME CONFIG_BT_DEVICE_NAME
#define DEVICE_NAME_LEN (sizeof(DEVICE_NAME) - 1)

/* The ble message must be an array of uint*/
/* [0] = start message pt 1, [1] = start message pt 2, [2] = vbat; [3] = fsr_1; [4] = fsr_2; [5] = fsr_3, [6] = calibration_button, [7] = status (including cal), [8] = band_is_connected (1 = connected)*/
uint8_t ble_msg []= {0x0B, 0xB0, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09};
static const struct bt_data ad[] = {
	BT_DATA_BYTES(BT_DATA_FLAGS, BT_LE_AD_NO_BREDR),
	BT_DATA_BYTES(BT_DATA_UUID16_ALL, 0xaa, 0xfe),
	BT_DATA(BT_DATA_SVC_DATA16, ble_msg, ARRAY_SIZE(ble_msg)) 
};

/* Set Scan Response data */
static const struct bt_data sd[] = {
	BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN),
};


static void bt_ready(int err)
{
	char addr_s[BT_ADDR_LE_STR_LEN];
	bt_addr_le_t addr = {0};
	size_t count = 1;

	if (err) {
		return;
	}

	/* Start advertising */
	err = bt_le_adv_start(BT_LE_ADV_NCONN_IDENTITY, ad, ARRAY_SIZE(ad),
			      sd, ARRAY_SIZE(sd));
	if (err) {
		return;
	}

	/* For connectable advertising you would use
	 * bt_le_oob_get_local().  For non-connectable non-identity
	 * advertising an non-resolvable private address is used;
	 * there is no API to retrieve that.
	 */

	bt_id_get(&addr, &count);
	bt_addr_le_to_str(&addr, addr_s, sizeof(addr_s));
}

void set_ble_msg (uint8_t vbat, uint8_t fsr1, uint8_t fsr2, uint8_t fsr3)
{
    int err;
    err = bt_le_adv_stop();
    k_msleep(5);

    ble_msg[2] = vbat;
    ble_msg[3] = fsr1;
    ble_msg[4] = fsr2;
    ble_msg[5] = fsr3;
    err = bt_le_adv_start(BT_LE_ADV_NCONN_IDENTITY, ad, ARRAY_SIZE(ad),
            sd, ARRAY_SIZE(sd));
}

void get_adc_readings (uint8_t* array)
{
    int16_t buf;
	struct adc_sequence sequence = {
		.buffer = &buf,
		/* buffer size in bytes, not number of samples */
		.buffer_size = sizeof(buf),
	};
    for(uint8_t i = 0; i < ARRAY_SIZE(adc_channels); i++)
    {
        // Iniitlize the adc read sequence
        (void)adc_sequence_init_dt(&adc_channels[i], &sequence);
        // Read the ADC channel (internall updates sequence.buf)
        (void)adc_read(adc_channels[i].dev, &sequence);
        // Upcast the buffer to a int32_t from int16_t
        array[i] = (uint8_t)buf; // 3.5V = 8192, 4V = <optimized out>
        // Do the conversion to Mv. based on the reference voltage
    }
}

//defines for switch case in main logic
#define START_CAL 0
#define SNAP_CAL 1
#define FIST_CAL 2
#define WSUP_CAL 3
#define WPRON_CAL 4
#define WUP_CAL 5
#define WDOWN_CAL 6
#define WAIT_FOR_SNAP 7
#define SEND_GESTURE 8

uint8_t fsr_1_adc_thresh = 0;
uint8_t fsr_2_adc_thresh = 0;
uint8_t fsr_3_adc_thresh = 0;


uint8_t get_button_press ()
{
    return gpio_pin_get_dt(&ui_btn);
}

uint8_t get_fsr_detect ()
{
    return gpio_pin_get_dt(&fsr_det);
}

#define THRESH_FACTOR 0.85

void snap_measurement_cal(uint8_t* max_snap_values)
{
	//this should read the adc readings for about 1 second after the haptic has been activated
	volatile uint8_t adc_readings[4] = {0, 0, 0, 0};
	for (int a  = 0; a < 1000; a++)
	{
		get_adc_readings(adc_readings);
		if (adc_readings[1] > max_snap_values[0])
		{
			max_snap_values[0] = adc_readings[1];
		}
		
		if (adc_readings[2] > max_snap_values[1])
		{
			max_snap_values[1] = adc_readings[2];
		}

		if (adc_readings[3] > max_snap_values[2])
		{
			max_snap_values[2] = adc_readings[3];
		}
		k_msleep(1);
	}
}


int snap_calibration(uint8_t* max_snap_values)
{
	play_haptic_buzz_normal();
	snap_measurement_cal(max_snap_values);
	k_msleep(1000);

	play_haptic_buzz_normal();
	snap_measurement_cal(max_snap_values);
	k_msleep(1000);

	play_haptic_buzz_normal();
	snap_measurement_cal(max_snap_values);
	k_msleep(1000);

	max_snap_values[0] *= THRESH_FACTOR;	
	max_snap_values[1] *= THRESH_FACTOR;
	max_snap_values[2] *= THRESH_FACTOR;

	int val=0;
	//wait for calibration process to start from user
	while (val != 1)
	{
		val = get_button_press();
	}
	//wait two second to check if the button is being held
	k_msleep(2000);
	val = get_button_press();
	if (val)
	{
		return 0;
	}
	return 1;
}

int gesture_calibration(uint8_t* max_snap_values, uint8_t* adc_readings, int gesture, int sample_num)
{
	//gesture = 0 is fist, 1 is wrist supanation, 2 is wrist pronation, 3 is wrist up, 4 is wrist down
	if (sample_num < 4)
	{
		//check for snap
		snap_measurement_cal(max_snap_values);
		k_msleep(1000);
	}
	return 1;
}


void state_machine_control(int* current_state, int* sample_num,  uint8_t* max_snap_values, uint8_t* adc_readings)
{
	//set the ble status to the state machine status
	int err = 0;
	ble_msg[7] = current_state;

	//variable that is sent over when gesture calibration is conducted
	int gesture;

	//poll buttons and set BLE message to be it
	int button_press = get_button_press();
	int fsr_connect = get_fsr_detect();
	ble_msg[6] = button_press;
	ble_msg[8] = fsr_connect;

	//get the adc readings each interval
    get_adc_readings(adc_readings);

	int gest_done = 0;

	switch (*current_state)
	{
		case START_CAL:
		{
			//Check for fsr detect and a button press to begin and change to snap cal state
			if (button_press==1 && fsr_connect==1)
			{
				current_state++;
			}
		}
		break;
		
		case SNAP_CAL:
		{
			//run snap cal and change state only when 
			err = snap_calibration(max_snap_values);
			if (err != 0)
			{
				current_state++;
				err=0;
			}
		}
		break;

		case FIST_CAL:
		{
			
		}
		break;

		case WSUP_CAL:
		{
			
		}
		break;

		case WPRON_CAL:
		{
			
		}
		break;

		case WUP_CAL:
		{
			
		}
		break;		

		case WDOWN_CAL:
		{
			
		}
		break;		

		case WAIT_FOR_SNAP:
		{
			
		}
		break;

		case SEND_GESTURE:
		{
			
		}
		break;		
	}
	set_ble_msg (adc_readings[0], adc_readings[1], adc_readings[2], adc_readings[3]);
}  

// Before main executes, zephyr-the RTOS, automatically initializes the pin in/out and set's up the clock
void main(void)
{
    volatile int err;
    volatile uint8_t adc_readings[4] = {0, 0, 0, 0};
	volatile uint8_t snap_max[4] = {0, 0, 0};
    k_msleep(1000);

  	/* Initialize the Bluetooth Subsystem */
    // err = bt_enable(bt_ready); //causes reset if used in gdb

    /* Initialize button and gpio inputs*/
    err = gpio_pin_configure_dt(&ui_btn, GPIO_INPUT);
	err = gpio_pin_configure_dt(&fsr_det, GPIO_INPUT);
	err = gpio_pin_interrupt_configure_dt(&ui_btn, GPIO_INT_EDGE_TO_ACTIVE);
	err = gpio_pin_interrupt_configure_dt(&fsr_det, GPIO_INT_EDGE_TO_ACTIVE);

    // Initialization
    gpio_pin_configure_dt(&blue_led, GPIO_OUTPUT_ACTIVE); //need to rename to chip select
    gpio_pin_set_dt(&blue_led, LED_ON);
	volatile uint16_t ignore = spi_read_write(0x00, 0x6E);

    for(uint8_t i = 0; i < ARRAY_SIZE(adc_channels); i++)
    {
        adc_channel_setup_dt(&adc_channels[i]);
    }

    // volatile int val;
    // volatile int val2;
	volatile int current_state = 0;

	/* SPI Initialization*/
	drivingCalculateWaveforms();
	// Begin main logic
	int num_gesture = 0;
    while(1){
		k_msleep(10);
		// if (val == 1)
		// {
		// 	play_haptic_buzz_normal();
		// }
        // get_adc_readings(adc_readings);
		state_machine_control(&current_state, snap_max, adc_readings, &num_gesture);
        // set_ble_msg (adc_readings[0], adc_readings[1], adc_readings[2], adc_readings[3]);
    };
}
