/*
 * Copyright (c) 2019 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <inttypes.h>
#include <stddef.h>
#include <stdint.h>
#include <errno.h>
#include <stdio.h>
#include <math.h>

#include <zephyr/kernel.h>
#include <zephyr/device.h>
// #include <zephyr/drivers/pwm.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/adc.h>
#include <zephyr/sys/util.h>
#include <zephyr/types.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/hci.h>
#include <zephyr/drivers/spi.h>


#if !DT_NODE_EXISTS(DT_PATH(zephyr_user)) || \
	!DT_NODE_HAS_PROP(DT_PATH(zephyr_user), io_channels)
#error "No suitable devicetree overlay specified"
#endif

// General note: DT == DeviceTree (.dts is device tree settings)

#define DT_SPEC_AND_COMMA(node_id, prop, idx) \
	ADC_DT_SPEC_GET_BY_IDX(node_id, idx),

/* Data of ADC io-channels specified in devicetree. */
// For each element in io_channels (an autogenerated node from the .dts file), get a handle to it's adc_dt_spec
static const struct adc_dt_spec adc_channels[] = {
	DT_FOREACH_PROP_ELEM(DT_PATH(zephyr_user), io_channels,
			     DT_SPEC_AND_COMMA)
};

#define LED_ON          0
#define LED_OFF         1

// Get the device tree handles by their friendly name from the macro-snap.dts file
// static const struct pwm_dt_spec cyber_led = PWM_DT_SPEC_GET(DT_ALIAS(pwm0));
static const struct gpio_dt_spec blue_led = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);
// static const struct gpio_dt_spec red_led = GPIO_DT_SPEC_GET(DT_ALIAS(led2), gpios);
// static const struct gpio_dt_spec cs_hapt = GPIO_DT_SPEC_GET(DT_ALIAS(spi0), gpios);
static const struct gpio_dt_spec ui_btn = GPIO_DT_SPEC_GET_OR(DT_ALIAS(uibtn), gpios,{0});
static const struct gpio_dt_spec fsr_det = GPIO_DT_SPEC_GET_OR(DT_ALIAS(fsrdet), gpios,{0});

/* SPI defines for the BOS1901 haptic driver*/
#define BOS1901_MANUFACTURER_ID_ADDR 0x02
#define BOS1901_REG_REF_ADDR 0x0
#define BOS1901_REG_REF_AMP_DATA 0b111110010010 //110 (calculated from formula for 12V output) in two's complement
#define BOS1901_REG_KP_ADDR 0x03
#define BOS1901_REG_KP_SQ_MASK 0b111111111111 //masks are setup to && with whatever is already in there
#define BOS1901_REG_KP_NO_SQ_MASK 0b011111111111
#define BOS1901_REG_KP_DATA 0x080
#define BOS1901_REG_KPA_KI_ADDR 0x04
#define BOS1901_REG_CONFIG_ADDR 0x05
#define BOS1901_REG_CONFIG_OE_MASK 0b111110010000 //masks are setup to && with whatever is already in there
#define BOS1901_REG_CONFIG_NO_OE_MASK 0b111110000000 //masks are setup to && with whatever is already in there

//Reference Values
#define REFERENCE_ZERO       0x0000
#define REFERENCE_PLUS_1LSB  0x0001
#define REFERENCE_MINUS_1LSB 0x0FFF

//Feedback
#define SIGNAL_SIZE_MAX             256 // Maximum table size
#define PRESS_SIGNAL_VOLTAGE        24  // Volts -> try making this larger
#define PRESS_SIGNAL_FREQ           80 // Hertz
#define REG_READ_VFEEDBACK_MASK     0x03FF

// Piezo Creep
#define CREEP_HOLD_TIME     40 // Cycles of 125us (8kHz)

// Timer
#define TIMER_PERIOD_ACCEL  3 // 3 ticks faster than 125-1

// Trimming
#define FIFO_SPACE_MASK (0x7F)
#define MAX_TRY         10800
#define TRIM_OSC_MAX_POS 0x1F
#define TRIM_OSC_MASK    0x3F

//playback defines
#define SAMPLING_RATE	(8000)
#define PLAY_SAMPLING_RATE (8000)


// variables for haptic algo
static uint16_t press_waveform[SIGNAL_SIZE_MAX];   // Press feedback waveform data points
static uint16_t press_waveform_size = 0;           // Press feedback waveform number of data points

// Period variables associated with interrupt timer2
static volatile uint32_t timer2DefaultPeriod;
static volatile uint32_t timer2NewPeriod;


//defines for switch case in main logic
#define START_CAL 0
#define SNAP_CAL 1
#define FIST_CAL 2
#define WSUP_CAL 3
#define WPRON_CAL 4
#define WUP_CAL 5
#define WDOWN_CAL 6
#define CALIB_DONE 7
#define WAIT_FOR_SNAP 8
#define SEND_GESTURE 9
#define THRESH_FACTOR_DIV 100
#define THRESH_FACTOR_MUL 95 //95
#define LOW_THRESH_FACTOR_MUL 90 //90
#define THRESH_OFFSET 5
#define SNAP_COUNT_MAX 25 // 11 this is the number of counts to ramp up and the num to ramp down, ideally this is odd
//GLOBAL VARS
int current_state = 0;
int num_gesture = 0;
int snap_state = 0; //this counter will check if the snap was done within the reasonable time frame for it to be a snap and not a fist
int sample_num = 0;
int upper_snap_threshold = 0;
int lower_snap_threshold = 0;
int fsr_with_snap_max = 0;
int override = 0;
//change this to be the size of SNAP_COUNT_MAX
uint8_t prev_adc_readings[SNAP_COUNT_MAX] = {0};

//////////////////////SPIIIIIII FUNCTIONS BEGIN /////////////////////////////////////////////////////////////////////////////////////////
///ALL the spi read_write shit ////////////////////////////////////////////
const struct device * spi_dev = DEVICE_DT_GET(DT_ALIAS(spizero)); 

//note that cs is being set by the blue LED gpio currently
static const struct spi_config spi_cfg = {
	.operation = SPI_WORD_SET(8) | SPI_TRANSFER_MSB |
		     SPI_MODE_CPOL | SPI_MODE_CPHA | SPI_OP_MODE_MASTER,
	.frequency = 8000000,
	.slave = 0, //0
	// .cs = 1,
};

uint16_t spi_read_write(uint8_t combo_word_1, uint8_t combo_word_2)
{
	int err;
	// static uint8_t tx_buffer[2]; //this should return the manufacturer id in rx buffer (hopefully)
	// static uint8_t rx_buffer[2];

	uint8_t rx_dummy= 0x00;
	uint8_t rx_dummy2= 0x00;

	struct spi_buf tx_buffer[] = 
	{
	{
		.buf = &combo_word_1,
		.len = (size_t) sizeof(combo_word_1)
	},
	{
		.buf = &combo_word_2,
		.len = (size_t) sizeof(combo_word_2)
	}
	};
	struct spi_buf rx_buffer[] = {
		{
		.buf = &rx_dummy,
		.len = (size_t) sizeof(rx_dummy)
		},
		{
		.buf = &rx_dummy2,
		.len = (size_t) sizeof(rx_dummy2)			
		}
	};

	struct spi_buf_set tx = {
		.buffers = tx_buffer,
		.count = 2
	};

	struct spi_buf_set rx = {
		.buffers = rx_buffer,
		.count = 2
	};
    gpio_pin_toggle_dt(&blue_led);
	err = spi_transceive(spi_dev, &spi_cfg, &tx, &rx);
    gpio_pin_toggle_dt(&blue_led);

	
	uint16_t rx_receive = ((uint16_t)rx_dummy << 8) | rx_dummy2;
	return rx_receive;
}
/////////////////////////////////////////////////////////////////////////////////////////

// Convert value in volts to Amplitude FIFO code
int16_t utilsVolt2Amplitude(float volt)
{
    int16_t amplitude = volt*2047/3.6/31;

    return amplitude;
}

// Calculate Press and Release Feedback Waveforms
static void drivingCalculateWaveforms(void)
{
    // Press Feedback Waveform : single sine pulse
	int boolean_switch_sign = 0;
	int counter = 0;
    press_waveform_size = PLAY_SAMPLING_RATE / PRESS_SIGNAL_FREQ; //about 44
    for(volatile uint8_t i = 0; i < press_waveform_size; i++)
    {
        //press_waveform[i] = utilsVolt2Amplitude(PRESS_SIGNAL_VOLTAGE / 2 * (sin(2*3*i/(press_waveform_size) - 3/2)+1));
		if (boolean_switch_sign == 1)
		{
			press_waveform[i] = utilsVolt2Amplitude(PRESS_SIGNAL_VOLTAGE);
		}
		else
		{
			press_waveform[i] = utilsVolt2Amplitude(0);
		}

		if (counter >= 2 && boolean_switch_sign == 0)
		{
			boolean_switch_sign = 1;
			counter = 0;
		}
		else if (counter >= 2 && boolean_switch_sign == 0)
		{
			boolean_switch_sign = 0;
			counter = 0;
		}
		else
		{
			counter++;
		}
	}
}



// Wait until BOS1901 internal FIFO is empty
static void drivingWaitFifoEmpty()
{
    bool fifoempty = 0;

    //Set up broadcast to read IC_STATUS
    spi_read_write(0x56, 0x17);  // Set BC = IC_STATUS

     // loop until FIFO is empty
    while(!fifoempty)
    {
        uint16_t ic_status_reg = spi_read_write(0xC0, 0x00); // dummy write, get IC_STATUS value
        fifoempty = (ic_status_reg >> 6) & 0x1; // extract EMPTY value.
    }
}

// Software trimming element function
bool drivingSoftwareTrim()
{
	uint16_t reg = 0;
    bool succeed = 0;
	
	//Need to disable the channel to do software trim
    spi_read_write(0x56, 0x07);

    //Set the mode to read trim values from register. Value will be available in TRIM_REGISTER and can be read from CONFIG BC
    spi_read_write(0xE8, 0x00); // TRIMRW = 2, SDOBP = 0, TRIM_OSC = 0, TRIM_REG = 0
	
    //Sets the CONFIG BC to read TRIM register
    spi_read_write(0x57, 0x07);

    //Read TRIM register and add 1 to TRIM_OSC
    reg = spi_read_write(0x57, 0x07);
    uint16_t regMask = 0x3 << 10 | 0x3F << 3;  // mask to manipulate register paramters TRIMRW and TRIM_OSC
    uint16_t TRIM_OSC = ((reg >> 3)  + 0x1) & TRIM_OSC_MASK; // gets TRIM_OSC value and increments 1
    succeed = (((reg >> 3) & TRIM_OSC_MASK) & TRIM_OSC_MAX_POS) != TRIM_OSC_MAX_POS; // check if reached maximum TRIM_OSC value
    reg &= ~regMask; // set TRIM_OSC bits to 0
    reg |= 0x3 << 10; // set TRIMRW to write mode
    reg |= TRIM_OSC << 3; // set new TRIM_OSC value
	uint8_t reg1 = (uint8_t)((reg & 0xFF00) >> 8);
	uint8_t reg2 = (uint8_t)(reg & 0x00FF);

	//Write the register with new TRIM_OSC parameter
    if(succeed)
    {
        spi_read_write(reg1, reg2);
    }
    
	// Reenable output and set BC back to IC_STATUS
    spi_read_write(0x56, 0x17);
    // Clear fifo before exiting
    drivingWaitFifoEmpty();
    
	k_msleep(1); // temp
    
    return succeed;
}

// Trim internal oscillator to fit MCU sampling rate
static void drivingTrimming(void) {


    // Initialization

	// Reset IC
	spi_read_write(0x56, 0xA7);  // Reset IC, set SDO broadcast to SENSE register to read VFEEDBACK, set PLAY sampling rate to 8kSPS.
	k_msleep(1);

	//Set the mode to latch hardware fuses to trim block. Data are available in TRIM register. Trimming will start at factory-trimmed value.
	spi_read_write(0xE4, 0x00); // TRIMRW = 1, SDOBP = 0, TRIM_OSC = 0, TRIM_REG = 0

	//sets BC to IC_STATUS & enables output, PLAY = 8kSPS
	spi_read_write(0x56, 0x17);

  	//set the timer at 8.2kHz to have BOS1901 FIFO clear faster than 8kHz
	 timer2NewPeriod = timer2DefaultPeriod - TIMER_PERIOD_ACCEL;

	uint16_t nbTry = 0;
	uint16_t FifoSpacePrev = 0;
	uint16_t FifoSpace = 0;
	bool FifoFull = 0;
	bool FifoEmpty = 0;
	for(;;) 
	{
			//Send 0 V and try to fill the fifo
			uint16_t reg = spi_read_write(0x00, 0x00);
			FifoSpace = reg & FIFO_SPACE_MASK;
			FifoFull = (reg >> 7) & 1;
			FifoEmpty = (reg >> 6) & 1;
			
			//First time the fifo will be the initial value (should be 0)
			if(nbTry == 0) 
			{
				FifoSpacePrev = FifoSpace;
			}
			nbTry++;
						
			//If FIFO has less space than before, data is accumulating in the FIFO
			if ((FifoSpace < FifoSpacePrev && !FifoEmpty) || FifoFull)
			{	
				if(drivingSoftwareTrim()) // increase oscillator speed
				{
					nbTry = 0;	// redo the loop until the trimming is OK																							
				}
			}
			
			//If you tried for a long time and did not succeed accumulating points in the fifo
			if(nbTry > MAX_TRY) 
			{
				break; // exit trimming loop
			}
		
	}								
	 spi_read_write(0x56, 0x07); // disable output once trimming is done.		

	//set the timer back to 8kHz
	 timer2NewPeriod = timer2DefaultPeriod - TIMER_PERIOD_ACCEL;
}
int counter = 0;
int last_sample = PLAY_SAMPLING_RATE / PRESS_SIGNAL_FREQ; 
// Phase C - Press Feedback Waveform
// Multiple entry function - entered every time the timer expires
static void drivingPressFeedback() 
{
	drivingWaitFifoEmpty(); // wait until BOS1901 internal FIFO is empty before sending the waveform points.
	spi_read_write(0x77, 0xE7);  // set SENSE = 0 to drive the output

    if(counter<last_sample) // playing the waveform
    {
		uint8_t reg1 = (uint8_t)((press_waveform[counter] & 0xFF00) >> 8);
		uint8_t reg2 = (uint8_t)(press_waveform[counter] & 0x00FF);
        spi_read_write(reg1, reg2);// Timer expired: send a new point
		counter++;
    } 
    else // waveform reached its last point
    {
        counter = 0;// cleanup
		uint8_t reg1 = (uint8_t)((press_waveform[counter] & 0xFF00) >> 8);
		uint8_t reg2 = (uint8_t)(press_waveform[counter] & 0x00FF);
        spi_read_write(reg1, reg2); // completing the waveform by playing the initial point again.
    }
}

// Phases D - Press Creep Stabilization
// Single entry function - executed once when called
static void drivingPressCreepStabilization()
{
    uint16_t ignore = spi_read_write(0x56, 0x07); // disable output once trimming is done.
	// uint8_t reg1 = (uint8_t)((REFERENCE_MINUS_1LSB & 0xFF00) >> 8);
	// uint8_t reg2 = (uint8_t)(REFERENCE_MINUS_1LSB & 0x00FF);	
    // spi_read_write(reg1, reg2);   // set FIFO to 0x0FFF
    // k_msleep(1000*CREEP_HOLD_TIME/SAMPLING_RATE); // wait defined time
}

void play_haptic_buzz_normal ()
{
	for (int a = 0; a < 100; a++)
	{
		drivingPressFeedback();
		k_msleep(5);
		drivingPressCreepStabilization(); //this causes output to be disabled
		k_msleep(5);
	}
}

//////////////////////SPIIIIIII FUNCTIONS END /////////////////////////////////////////////////////////////////////////////////////////
//for bluetooth test
#define DEVICE_NAME CONFIG_BT_DEVICE_NAME
#define DEVICE_NAME_LEN (sizeof(DEVICE_NAME) - 1)

/* The ble message must be an array of uint*/
/* [0] = start message pt 1, [1] = start message pt 2, [2] = vbat; [3] = fsr_1; [4] = fsr_2; [5] = fsr_3, [6] = calibration_button, [7] = status (including cal), [8] = band_is_connected (1 = connected)*/
uint8_t ble_msg []= {0x0B, 0xB0, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10};
static const struct bt_data ad[] = {
	BT_DATA_BYTES(BT_DATA_FLAGS, BT_LE_AD_NO_BREDR),
	BT_DATA_BYTES(BT_DATA_UUID16_ALL, 0xaa, 0xfe),
	BT_DATA(BT_DATA_SVC_DATA16, ble_msg, ARRAY_SIZE(ble_msg)) 
};

/* Set Scan Response data */
static const struct bt_data sd[] = {
	BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN),
};


static void bt_ready(int err)
{
	char addr_s[BT_ADDR_LE_STR_LEN];
	bt_addr_le_t addr = {0};
	size_t count = 1;

	if (err) {
		return;
	}

	/* Start advertising */
	err = bt_le_adv_start(BT_LE_ADV_NCONN_IDENTITY, ad, ARRAY_SIZE(ad),
			      sd, ARRAY_SIZE(sd));
	if (err) {
		return;
	}

	/* For connectable advertising you would use
	 * bt_le_oob_get_local().  For non-connectable non-identity
	 * advertising an non-resolvable private address is used;
	 * there is no API to retrieve that.
	 */

	bt_id_get(&addr, &count);
	bt_addr_le_to_str(&addr, addr_s, sizeof(addr_s));
}

void set_ble_msg (uint8_t vbat, uint8_t fsr1, uint8_t fsr2, uint8_t fsr3)
{
    int err;
    err = bt_le_adv_stop();
    k_msleep(5);

    ble_msg[2] = vbat;
    ble_msg[3] = fsr1;
    ble_msg[4] = fsr2;
    ble_msg[5] = fsr3;
    err = bt_le_adv_start(BT_LE_ADV_NCONN_IDENTITY, ad, ARRAY_SIZE(ad),
            sd, ARRAY_SIZE(sd));
}

void get_adc_readings (uint8_t* array)
{
    int16_t buf;
	struct adc_sequence sequence = {
		.buffer = &buf,
		/* buffer size in bytes, not number of samples */
		.buffer_size = sizeof(buf),
	};
    for(uint8_t i = 0; i < ARRAY_SIZE(adc_channels); i++)
    {
        // Iniitlize the adc read sequence
        (void)adc_sequence_init_dt(&adc_channels[i], &sequence);
        // Read the ADC channel (internall updates sequence.buf)
        (void)adc_read(adc_channels[i].dev, &sequence);
        // Upcast the buffer to a int32_t from int16_t
        array[i] = (uint8_t)buf; // 3.5V = 8192, 4V = <optimized out>
        // Do the conversion to Mv. based on the reference voltage
    }
}



uint8_t get_button_press ()
{
    return gpio_pin_get_dt(&ui_btn);
}

uint8_t get_fsr_detect ()
{
    return gpio_pin_get_dt(&fsr_det);
}


void snap_measurement_cal(uint8_t* sum_values_maxes)
{
	//this should read the adc readings for about 1 second after the haptic has been activated
	uint8_t adc_vals[4] = {0, 0, 0, 0};
	uint8_t max_snap_values[3] = {0, 0, 0};

	for (int a  = 0; a < 100; a++)
	{
		get_adc_readings(adc_vals);
		if (adc_vals[1] > max_snap_values[0] && adc_vals[1] < 255)
		{
			max_snap_values[0] = adc_vals[1];
		}
		
		if (adc_vals[2] > max_snap_values[1] && adc_vals[2] < 255)
		{
			max_snap_values[1] = adc_vals[2];
		}

		if (adc_vals[3] > max_snap_values[2] && adc_vals[3] < 255)
		{
			max_snap_values[2] = adc_vals[3];
		}
		set_ble_msg (adc_vals[0], adc_vals[1], adc_vals[2], adc_vals[3]);
		k_msleep(5);
	}
	sum_values_maxes[0] += max_snap_values[0];
	sum_values_maxes[1] += max_snap_values[1];
	sum_values_maxes[2] += max_snap_values[2];

}


int snap_calibration(uint8_t* max_snap_values)
{
	uint8_t sum_values_maxes[3] = {0, 0, 0};
	play_haptic_buzz_normal();
	snap_measurement_cal(sum_values_maxes);
	k_msleep(1000);

	play_haptic_buzz_normal();
	snap_measurement_cal(sum_values_maxes);
	k_msleep(1000);

	play_haptic_buzz_normal();
	snap_measurement_cal(sum_values_maxes);
	k_msleep(1000);

	max_snap_values[0] = sum_values_maxes[0]/3;
	max_snap_values[1] = sum_values_maxes[1]/3;
	max_snap_values[2] = sum_values_maxes[2]/3;

	// int new_snap_0 = max_snap_values[0]* THRESH_FACTOR_MUL / THRESH_FACTOR_DIV;	
	// int new_snap_1 = max_snap_values[1]* THRESH_FACTOR_MUL / THRESH_FACTOR_DIV;
	// int new_snap_2 = max_snap_values[2]* THRESH_FACTOR_MUL / THRESH_FACTOR_DIV;


	if (max_snap_values[0] >= max_snap_values[1] && max_snap_values[0] >= max_snap_values[2])
	{
		fsr_with_snap_max = 0;
		upper_snap_threshold = max_snap_values[0]* THRESH_FACTOR_MUL / THRESH_FACTOR_DIV;
		lower_snap_threshold = max_snap_values[0]* LOW_THRESH_FACTOR_MUL / THRESH_FACTOR_DIV;
	}
	else if (max_snap_values[1] >= max_snap_values[2])
	{
		fsr_with_snap_max = 1;
		upper_snap_threshold = max_snap_values[1]* THRESH_FACTOR_MUL / THRESH_FACTOR_DIV;
		lower_snap_threshold = max_snap_values[1]* LOW_THRESH_FACTOR_MUL / THRESH_FACTOR_DIV;
	}
	else
	{
		fsr_with_snap_max = 2;
		upper_snap_threshold = max_snap_values[2]* THRESH_FACTOR_MUL / THRESH_FACTOR_DIV;
		lower_snap_threshold = max_snap_values[2]* LOW_THRESH_FACTOR_MUL / THRESH_FACTOR_DIV;
	}

	int val=0;
	//wait for calibration process to continue from user
	while (val == 0)
	{
		val = get_button_press();
	}
	//wait one second to check if the button is being held
	k_msleep(1000);
	val = get_button_press();
	if (val == 1)
	{
		return 0;
	}
	return 1;
}

int gesture_calibration(uint8_t* adc_readings)
{
	//gesture = 0 is fist, 1 is wrist supanation, 2 is wrist pronation, 3 is wrist up, 4 is wrist down
	//snap is detected, the haptic is played
	play_haptic_buzz_normal();
	for (int a  = 0; a < 150; a++)
	{
		ble_msg[9] = 1;
		get_adc_readings(adc_readings);
		set_ble_msg (adc_readings[0], adc_readings[1], adc_readings[2], adc_readings[3]);
		k_msleep(5);
	}
	//long haptic for gesture detected
	play_haptic_buzz_normal();	
	play_haptic_buzz_normal();
	sample_num++;
	return 1;
}

void gesture_reading(uint8_t* adc_readings)
{
	play_haptic_buzz_normal();
	for (int a  = 0; a < 150; a++)
	{
		ble_msg[9] = 1;
		get_adc_readings(adc_readings);
		set_ble_msg (adc_readings[0], adc_readings[1], adc_readings[2], adc_readings[3]);
		k_msleep(5);
	}
	//long haptic for gesture detected
	play_haptic_buzz_normal();	
	play_haptic_buzz_normal();
}

void shift_snap_window (int new_reading)
{
	for (int a = 0; a < SNAP_COUNT_MAX-1; a++)
	{
		prev_adc_readings[a] = prev_adc_readings[a+1];
	}

	prev_adc_readings[SNAP_COUNT_MAX-1] = new_reading;
}

void clear_adc_readings()
{
	for (int a = 0; a < SNAP_COUNT_MAX; a++)
	{
		prev_adc_readings[a] = 0;
	}	
}

//return 0 for successful snap, 1 otherwise
int check_if_snap (uint8_t* max_snap_values, uint8_t* adc_readings)
{
	shift_snap_window(adc_readings[fsr_with_snap_max+1]);
	// get_adc_readings(adc_readings);
	if (prev_adc_readings [(SNAP_COUNT_MAX-1)/2] >= upper_snap_threshold && prev_adc_readings[0] < lower_snap_threshold && prev_adc_readings[SNAP_COUNT_MAX-1] < lower_snap_threshold)
	{
		clear_adc_readings();
		return 0;
	}
	// if ((adc_readings[1] < max_snap_values[0]+THRESH_OFFSET && adc_readings[2] < max_snap_values[1]+THRESH_OFFSET) || (adc_readings[2] < max_snap_values[1]+THRESH_OFFSET && adc_readings[3] < max_snap_values[2]+THRESH_OFFSET) || (adc_readings[1] < max_snap_values[0]+THRESH_OFFSET && adc_readings[3] < max_snap_values[2]+THRESH_OFFSET))
	// {
	// 	k_msleep(5);
	// 	get_adc_readings(adc_readings);
	// 	if (adc_readings[1] >= max_snap_values[0] && adc_readings[2] >= max_snap_values[1] && adc_readings[3] >= max_snap_values[2])
	// 	{
	// 		k_msleep(50);
	// 		get_adc_readings(adc_readings);
	// 		if (adc_readings[1] < max_snap_values[0]+THRESH_OFFSET || adc_readings[2] < max_snap_values[1]+THRESH_OFFSET || adc_readings[3] < max_snap_values[2]+THRESH_OFFSET)
	// 		//if ((adc_readings[1] < max_snap_values[0] && adc_readings[2] < max_snap_values[1]) || (adc_readings[2] < max_snap_values[1] && adc_readings[3] < max_snap_values[2]) || (adc_readings[1] < max_snap_values[0] && adc_readings[3] < max_snap_values[2]))
	// 		{
	// 			return 0;
	// 		}
	// 	}
	// }
	// else
	// {
	// 	k_msleep(5);
	// }
	return 1;
}

void state_machine_control(uint8_t* max_snap_values, uint8_t* adc_readings)
{
	//set the ble status to the state machine status
	int err = 0;
	ble_msg[7] = current_state;
	//ble byte that is sent over when gesture calibration is conducted
	ble_msg[9] = 0;
	//poll buttons and set BLE message to be it
	int button_press = get_button_press();
	int fsr_connect = get_fsr_detect();
	ble_msg[6] = button_press;
	ble_msg[8] = fsr_connect;

	//get the adc readings each interval
    get_adc_readings(adc_readings);

	int no_snap = 1;


	//when gesture is done this will be 1
	int gest_done = 0;
	if (current_state == START_CAL)
	{
			//Check for fsr detect and a button press to begin and change to snap cal state
			if (button_press==1 && fsr_connect==1)
			{
				current_state++;
				ble_msg[7] = current_state;
				k_msleep(500);
			}
	}
	else if (current_state == SNAP_CAL)
	{
		if (button_press == 1)
		{
			//run snap cal and change state only when 
			err = snap_calibration(max_snap_values);
			if (err == 1)
			{
				current_state++;
				err=0;
			}
		}
	}
	else if (current_state == FIST_CAL)
	{
		no_snap = check_if_snap(max_snap_values, adc_readings);
		//if no_snap is 0 this means there is snap
		if (no_snap == 0)
		{
			gest_done = gesture_calibration(adc_readings);
			no_snap = 1;
			ble_msg[9] = 0;
		}
		if (button_press == 1)
		{
			k_msleep(750);
			err = get_button_press();
			if (err == 0)
			{
				current_state++;
			}
			else
			{
				while (err == 1)
				{
					err = get_button_press();
				}
				ble_msg[9] = 2;
				set_ble_msg (adc_readings[0], adc_readings[1], adc_readings[2], adc_readings[3]);
				k_msleep(400);
				ble_msg[9] = 0;
			}
			sample_num = 0;
		}
	}
	else if (current_state == WSUP_CAL)
	{
		no_snap = check_if_snap(max_snap_values, adc_readings);
		//if no_snap is 0 this means there is snap
		if (no_snap == 0)
		{
			gest_done = gesture_calibration( adc_readings);
			no_snap = 1;

		}
		if (button_press == 1)
		{
			k_msleep(750);
			err = get_button_press();
			if (err == 0)
			{
				current_state++;
			}
			else
			{
				while (err == 1)
				{
					err = get_button_press();
				}
				ble_msg[9] = 2;
				set_ble_msg (adc_readings[0], adc_readings[1], adc_readings[2], adc_readings[3]);
				k_msleep(400);
				ble_msg[9] = 0;
			}
			sample_num = 0;
		}
	}
	else if (current_state == WPRON_CAL) 
	{
		no_snap = check_if_snap(max_snap_values, adc_readings);
		//if no_snap is 0 this means there is snap
		if (no_snap == 0)
		{
			gest_done = gesture_calibration(adc_readings);
			no_snap = 1;

		}
		if (button_press == 1)
		{
			k_msleep(750);
			err = get_button_press();
			if (err == 0)
			{
				current_state++;
			}
			else
			{
				while (err == 1)
				{
					err = get_button_press();
				}
				ble_msg[9] = 2;
				set_ble_msg (adc_readings[0], adc_readings[1], adc_readings[2], adc_readings[3]);
				k_msleep(400);
				ble_msg[9] = 0;
			}
			sample_num = 0;
		}
	}
	else if (current_state == WUP_CAL) 
	{
		no_snap = check_if_snap(max_snap_values, adc_readings);
		//if no_snap is 0 this means there is snap
		if (no_snap == 0)
		{
			gest_done = gesture_calibration(adc_readings);
			no_snap = 1;
		}
		if (button_press == 1)
		{
			k_msleep(750);
			err = get_button_press();
			if (err == 0)
			{
				current_state++;
			}
			else
			{
				while (err == 1)
				{
					err = get_button_press();
				}
				ble_msg[9] = 2;
				set_ble_msg (adc_readings[0], adc_readings[1], adc_readings[2], adc_readings[3]);
				k_msleep(400);
				ble_msg[9] = 0;
			}
			sample_num = 0;
		}
	}
	else if (current_state == WDOWN_CAL) 
	{
		no_snap = check_if_snap(max_snap_values, adc_readings);
		//if no_snap is 0 this means there is snap
		if (no_snap == 0)
		{
			gest_done = gesture_calibration(adc_readings);
			no_snap = 1;

		}
		if (button_press == 1)
		{
			k_msleep(750);
			err = get_button_press();
			if (err == 0)
			{
				current_state++;
			}
			else
			{
				while (err == 1)
				{
					err = get_button_press();
				}
				ble_msg[9] = 2;
				set_ble_msg (adc_readings[0], adc_readings[1], adc_readings[2], adc_readings[3]);
				k_msleep(400);
				ble_msg[9] = 0;
			}
			sample_num = 0;
		}
	}
	else if (current_state == CALIB_DONE)
	{
		if (button_press == 1)
		{
			current_state++;
			ble_msg[7] = current_state;
		}
	}
	else if (current_state == WAIT_FOR_SNAP) 
	{
		no_snap = check_if_snap(max_snap_values, adc_readings);
		//if no_snap is 0 this means there is snap
		if (no_snap == 0)
		{
			current_state++;
			k_msleep(1000);
		}
	}	
	else if (current_state == SEND_GESTURE) 
	{
		gesture_reading(adc_readings);
		current_state--;
		k_msleep(1000);
	}
	k_msleep(5);
	// if (current_state != WAIT_FOR_SNAP)
	// {
	set_ble_msg (adc_readings[0], adc_readings[1], adc_readings[2], adc_readings[3]);
	// }
}  

// Before main executes, zephyr-the RTOS, automatically initializes the pin in/out and set's up the clock
void main(void)
{
    int err;
    uint8_t adc_readings[4] = {0, 0, 0, 0};
	uint8_t snap_max[3] = {0, 0, 0};
    k_msleep(100);

  	/* Initialize the Bluetooth Subsystem */
    err = bt_enable(bt_ready); //causes reset if used in gdb

    /* Initialize button and gpio inputs*/
    err = gpio_pin_configure_dt(&ui_btn, GPIO_INPUT);
	err = gpio_pin_configure_dt(&fsr_det, GPIO_INPUT);
	err = gpio_pin_interrupt_configure_dt(&ui_btn, GPIO_INT_EDGE_TO_ACTIVE);
	err = gpio_pin_interrupt_configure_dt(&fsr_det, GPIO_INT_EDGE_TO_ACTIVE);

    // Initialization
    gpio_pin_configure_dt(&blue_led, GPIO_OUTPUT_ACTIVE); //need to rename to chip select
    gpio_pin_set_dt(&blue_led, LED_ON);
	volatile uint16_t ignore = spi_read_write(0x00, 0x6E);

    for(uint8_t i = 0; i < ARRAY_SIZE(adc_channels); i++)
    {
        adc_channel_setup_dt(&adc_channels[i]);
    }
	/* SPI Initialization*/
	drivingCalculateWaveforms();
	// Begin main logic
    while(1){
		state_machine_control(snap_max, adc_readings);
    };
}
